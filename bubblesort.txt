Command
./xsm -l library.lib -e Output2.xsm   
 cp Output2.xsm /mnt/c/Users/Teresa/Downloads/xsm_expl/xsm_expl/  
decl int a,b,c,fact(int n) enddecl a=99 b=88 c=fact(a,b)
while(i<n) do write(arr[i]) i = i+1 endwhile
Stage5
DONE bubble sort with int main() :decl int n,arr[50],i,j,dup enddecl int main () {decl enddecl begin read(n)   i=0   while(i<n) do     read(arr[i])     i = i+1   endwhile   i=0   while(i<n) do     j=i     while(j<n) do       if(arr[i]>arr[j]) then         dup = arr[i]        arr[i] = arr[j]        arr[j] = dup      endif j = j + 1     endwhile    i = i+1   endwhile   i=0   while(i<n) do     write(arr[i])     i = i+1   endwhile   return 0 end }
DONE constant decl int fun(int x),a enddecl int fun(int x) {decl enddecl begin if(x >= 91) then a = 91 else a = fun(fun(x+11)) endif  return a end } int main() { decl int b,c enddecl begin read(b) c = fun(b) write(c) return 0 end }
DONE constant simple decl int fun(int x),a enddecl int fun(int x) {decl enddecl begin if(x >= 91) then a = 91 else a = x+11 endif  return a end } int main() { decl int b,c enddecl begin read(b) c = fun(b) write(c) return 0 end }
PROBLEM Bubble Sort Recursive:: decl int n,arr[10],i,j,dup, BubbleSort(int first, int last) enddecl int BubbleSort(int first, int last) { decl int temp enddecl begin if((first < last) AND (last > 0)) then if(arr[first] > arr[first+1]) then temp = arr[first] arr[first] = arr[first+1] arr[first+1] = temp endif dup = BubbleSort(first+1, last) dup = BubbleSort(first, last-1) endif return 0 end }
DONE PROBLEM QUICK SORT ::decl int a,b,n,arr[10]  int swap(int index, int newindex) int readarr(int temp)  int writearr(int temp) int partition (int low, int high) int quicksort(int low,int high) enddecl int swap(int index ,int newindex) { decl int s enddecl begin s = arr[index] arr[index] = arr[newindex]  arr[newindex] = s return s end } int readarr(int temp) {  decl int count enddecl begin  count=0  while(count < temp) do  read(arr[count]) count=count+1 endwhile return count end } int writearr(int temp) { decl int count enddecl begin count = 0  while(count < temp) do write(arr[count]) count = count+1 endwhile return count end } int partition (int low, int high) { decl int pivot,t int i,j enddecl begin pivot = arr[high] j = low i = low  while(i < high) do if (arr[i] <= pivot) then t = swap (i , j) j = j+1  endif i=i+1  endwhile i = swap (j , high) return j end } int quicksort (int low , int high) { decl int pp,temp,t enddecl begin if (low < high) then pp = partition (low , high) temp = quicksort(pp+1,high) t = quicksort(low , pp-1) endif return 1  end } int main() {  decl int junk int temp enddecl begin read(n) junk = readarr(n) temp = quicksort(0,n-1) junk = writearr(n) return junk end }
DONE FIBINOCCI RECURSIVE:: decl int n,fibo(int n) enddecl int fibo(int n){ decl	int res	enddecl	begin	if(n==0)then res=0 else if(n==1)then res=1 else	res=fibo(n-1)+fibo(n-2) endif 	endif return res end } int main(){ decl int result enddecl begin		read(n) result = fibo(n) write(result) return 0 end	}
DONE EXTENDED EUCLIDAIN WITH A FUNCTION ITERATIVE ::decl int ExtendedEuclid(int a,int b) enddecl int ExtendedEuclid(int a,int b) { decl int r0,r1,s0,s1,t0,t1,qi,ri,si,ti enddecl begin  r0 = a r1 = b s0 = 1 s1 = 0 t0 = 0  t1 = 1 while(r1 != 0) do qi = r0/r1   ri = r0 - (qi*r1)  si = s0 - (qi*s1)  ti = t0 - (qi*t1)  r0 = r1 r1 = ri s0 = s1 s1 = si t0 = t1 t1 = ti endwhile write(r0)  write(s0) write(t0)  return 0 end } int main() { decl int a,b,c enddecl begin read(a) read(b) c = ExtendedEuclid(a,b) return 0 end } 
DONE EXTENDED EUCLIDAIAN ITERATIVE WITHOUT FUNCTION::decl int r1,qi,r0,si,ti,ri enddecl int main() {  decl  int s0,s1,t0,t1 enddecl begin  read(r0) read(r1) s0 = 1 s1 = 0   t0 = 0 t1 = 1 while(r1 != 0) do qi = r0/r1  ri = r0 - (qi*r1)   si = s0 - (qi*s1)  ti = t0 - (qi*t1)  r0 = r1 r1 = ri  s0 = s1 s1 = si t0 = t1 t1 = ti endwhile write(r0) write(s0) write(t0)  return 0 end }
DONE FACTORIAL RECURSIVE:: decl int fact(int n) enddecl int fact(int n) { decl int f  enddecl  begin if(n<=1) then f=1 else f=n*fact(n-1) endif return f end } int main() { decl int a,res   enddecl begin  read(a) res = fact(a) write(res) return 0 end  }
Simple Func with 3 arguments::decl int fun(int x,int y,int z),a; enddecl int fun(int x,int y,int z) {decl enddecl begin write(x); write(y); write(z); return x; end } int main() { decl int b,c,d; enddecl begin read(b); read(c); read(d); c = fun(b,c,d); return 0; end }
Simple Func with 2 arguments::decl int fun(int x,int y),a; enddecl int fun(int x,int y) {decl enddecl begin write(x); write(y);  return x; end } int main() { decl int b,c; enddecl begin read(b); read(c); c = fun(b,c); write(c); return 0; end }
Stage 4
Sum of Facts::decl int n,i,j,sum,k enddecl read(n) sum=0 k=1 while(k<=n)do if(n<=1) then sum=sum+1 else i=1 j=1 while(i<=k)do j=j*i i=i+1 endwhile sum=sum+j endif k=k+1 endwhile write(sum)
Prime or not decl int n,i,j enddecl read(n) j=0 if(n%2 ==0) then j=1 else i=3 while(i <= n/2) do if(n%i == 0) then j=1 endif i=i+1 endwhile endif if(j==0) then write("Prime") else write("Not Prime") endif
Read n decl  int n,arr[50],i,j,dup enddecl  read(n)   i=0   while(i<n) do     read(arr[i])     i = i+1   endwhile   i=0 while(i<n) do write(arr[i]) i = i+1 endwhile  
Fibin: decl int n,f2,f0,f1,i enddecl read(n) if(n>=2) then f0=0 f1=1 n=n-1 while(n!=0) do f2=f1+f0 f0=f1 f1=f2 n=n-1 endwhile write(f1) else if(n==1) then write(1) else write(0) endif endif
Bubble sort:decl    int n,arr[50],i,j,dup enddecl  read(n)   i=0   while(i<n) do     read(arr[i])     i = i+1   endwhile   i=0   while(i<n) do     j=i     while(j<n) do       if(arr[i]>arr[j]) then         dup = arr[i]        arr[i] = arr[j]        arr[j] = dup      endif j = j + 1     endwhile    i = i+1   endwhile   i=0   while(i<n) do     write(arr[i])     i = i+1   endwhile
Stage 6
LINKEDLIST WITH ;type List { int data; List next; } endtype decl List head; enddecl int main() { decl int length, x; List p, q; enddecl begin x = initialize(); head=null; read(length); q=head; while (length!=0)  do   read(x); p=alloc(); p.data=x; p.next=null; if (head==null) then head=p; q=p;  else q.next=p;  q=q.next; endif; length=length-1;  endwhile;  p=head; while(p!=null)  do write(p.data); p=p.next; endwhile;  return 1; end }
BST SEARCH TREE WITH ;
type bst{ int a; bst left; bst right; } endtype decl int in,opt; bst insert(bst h, int key);  int inOrder(bst h);  int preOrder(bst h);  int postOrder(bst h);      enddecl bst insert(bst h, int key) {  begin    if (h == null) then   h = alloc();  h.a = key; h.left = null;   h.right = null; else if (key < h.a) then  h.left  = insert(h.left, key);  else if (key > h.a) then  h.right = insert(h.right, key); endif; endif; endif;      return h;  end } int inOrder(bst h){  begin if(h!=null) then in=inOrder(h.left);  write(h.a);   in=inOrder(h.right); endif;  return 1; end } int preOrder(bst h){  begin if(h!=null) then    write(h.a); in=preOrder(h.left); in=preOrder(h.right); endif; return 1; end} int postOrder(bst h){  begin  if(h!=null) then   in=postOrder(h.left); in=postOrder(h.right); write(h.a); endif;  return 1; end } int main() {   decl int val,flag; bst Root; enddecl begin val = initialize();  Root = null; read(val); while(val!=0) do Root = insert(Root,val); read(val); endwhile;  in = inOrder(Root); in = preOrder(Root);in = postOrder(Root);  return 9; end}
DONE Linkedlist ::  type List { int data List next} endtype decl List head enddecl int main() { decl int length, x List p, q enddecl begin x = initialize() head=null read(length) q=head while (length!=0)  do read(x) p=alloc() p.data=x p.next=null      if (head==null) then head=p q=p else q.next=p q=q.next  endif length=length-1 endwhile     p=head while(p!=null)  do write(p.data) p=p.next endwhile  return 1 end }
DONE BST Search Tree ::type bst{ int a bst left bst right } endtype decl int in,opt bst insert(bst h, int key) int inOrder(bst h) int preOrder(bst h) int postOrder(bst h) enddecl bst insert(bst h, int key) { begin if (h == null) then h = alloc() h.a = key h.left = null  h.right = null  else if (key < h.a) then h.left  = insert(h.left, key) else if (key > h.a) then  h.right = insert(h.right, key) endif endif endif return h end } int inOrder(bst h){ begin if(h!=null) then in=inOrder(h.left) write(h.a) in=inOrder(h.right) endif return 1 end } int preOrder(bst h){ begin if(h!=null) then write(h.a) in=preOrder(h.left) in=preOrder(h.right)  endif return 1 end } int postOrder( bst h){ begin if(h!=null) then in=postOrder(h.left) in=postOrder(h.right) write(h.a) endif return 1 end } int main() { decl int val,flag bst Root enddecl  begin val = initialize()    Root = null read(val) while(val!=0) do Root = insert(Root,val) read(val) endwhile in = inOrder(Root) in = preOrder(Root) in = postOrder(Root) return 9 end }
DONE type marks{int a int b} endtypeint main() {decl enddecl begin a=99 end}
DONE Simple const fuction with type::: type marks{int a int b} linkedlist {int val linkedlist next} endtype decl int fun(int x),a enddecl int fun(int x) {decl enddecl begin if(x >= 91) then a = 91 else a = x+11 endif  return a end } int main() { decl int b,c enddecl begin read(b) c = fun(b) write(c) return 0 end }
DONE type marks{int a int b} linkedlist {int val linkedlist next} endtype int main() {decl int a enddecl begin a=99 end}
DONE Extended Euclid Algorithm using Userdefined types:: type node {    int d int s int t } endtype decl node y,z,gcd(int a,int b) enddecl node gcd(int a,int b) { decl int q,r,temp enddecl begin if(b==0) then y.d = a  y.s = 1 y.t = 0 else   q = a/b  r = a%b z = gcd(b,r) temp = z.s y.s = z.t  y.t = temp - (q*z.t) endif return y end } int main() { decl node res   int a,b,c   enddecl  begin c = initialize() y = alloc() read(a) read(b) res = gcd(a,b)  write(res.d) write(res.s) write(res.t) return 0 end }
type node { int d int s int t } List {  int a  int b node g List next } endtype decl node y,z List head  int insert(int a,int b,node g) node gcd(int m,int n) enddecl int insert(int a,int b,node g) {  decl List p,q node temp enddecl begin p=alloc() p.a=a p.b=b temp=alloc()  temp.d=g.d temp.s=g.s temp.t=g.t  p.g=temp if (head== null) then p.next=null head=p else p.next=head head=p endif return 0 end} node gcd(int m,int n){  decl  int q,r,temp enddecl  begin if(n==0) then  y.d = m y.s = 1 y.t = 0 else  q = m/n r = m-q*n z = gcd(n,r) temp = z.s y.s = z.t y.t = temp - (q*z.t) endif temp=insert(m,n,y)  return y  end } int main() { decl int a,b,c  node res enddecl begin c = initialize() y = alloc()  read(a) read(b) head=null res = gcd(a,b) write(res.d) write(res.s) write(res.t) while(head!= null) do write(1) endwhile return 0 end }
DONE Extended Euclid Algorithm using linkedlist::type node { int d int s int t } List {  int a  int b node g List next } endtype decl node y,z List head  int insert(int a,int b,node g) node gcd(int m,int n) enddecl int insert(int a,int b,node g) {  decl List p,q node temp enddecl begin p=alloc() p.a=a p.b=b temp=alloc()  temp.d=g.d temp.s=g.s temp.t=g.t  p.g=temp if (head== null) then p.next=null head=p else p.next=head head=p endif return 0 end} node gcd(int m,int n){  decl  int q,r,temp enddecl  begin if(n==0) then  y.d = m y.s = 1 y.t = 0 else  q = m/n r = m-q*n z = gcd(n,r) temp = z.s y.s = z.t y.t = temp - (q*z.t) endif temp=insert(m,n,y)  return y  end } int main() { decl int a,b,c  node res enddecl begin c = initialize() y = alloc()  read(a) read(b) head=null res = gcd(a,b) write(res.d) write(res.s) write(res.t) while(head!= null) do write(head.a) write(head.b) write(head.g.d) write(head.g.s) write(head.g.t) head=head.next endwhile return 0 end }

Extended Euclidian
type node { int d;int s; int t;} List  { int a; int b;node g;List next;} endtype decl node y,z;  List head; int insert(int a,int b,node g); node gcd(int m,int n); enddecl int insert(int a,int b,node g) { decl  List p,q; node temp; enddecl begin p=alloc(); p.a=a;   p.b=b; temp=alloc(); temp.d=g.d; temp.s=g.s; temp.t=g.t; p.g=temp; if (head== null) then  p.next=null; head=p; else p.next=head;   head=p; endif; return 0; end } node gcd(int m,int n){ decl int q,r,temp;  enddecl begin   if(n==0) then   y.d = m;y.s = 1; y.t = 0;   else  q = m/n;  r = m-q*n;  z = gcd(n,r);   temp = z.s; y.s = z.t;  y.t = temp - (q*z.t);    endif;  temp=insert(m,n,y);  return y; end } int main() { decl int a,b,c;  node res; enddecl  begin c = initialize();    y = alloc();  read(a);  read(b); head=null; res = gcd(a,b); write(res.d); write(res.s); write(res.t); while(head!= null) do write(head.a); write(head.b);write(head.g.d);write(head.g.s);write(head.g.t);head=head.next;endwhile; return 0; end}


STAGE 7:
type list{ int data; list next; } endtype class linkedlist{ decl list head; list tail; int length; int getlength(); int init();list insert(int data);int printlinkedlist();enddecl int getlength(){ decl enddecl begin return self.length;end} int init(){ decl enddecl begin self.head=null;self.tail=null; self.length=0;	return 1; end } list insert(int data){ decl list temp; enddecl begin temp=alloc(); temp.data=data; temp.next=null; if(self.head== null)then self.head=temp; self.tail=temp; else self.tail.next=temp; self.tail=temp; endif; self.length=self.length+1; return temp; end } int printlinkedlist(){ decl list temp; enddecl begin temp=self.head; 	while(temp!= null)do write(temp.data); temp=temp.next; endwhile; return 1; end } } endclass decl linkedlist obj; enddecl int main(){ decl int x,y,z; 	list a;	enddecl begin x=initialize(); obj=new(linkedlist); x=obj.init(); read(x); while(x!=0)do read(y); a=obj.insert(y); x=x-1; endwhile; write(obj.getlength()); x=obj.printlinkedlist(); return 1; end }